## Lock

### Scalable Lock
Non-scalable lock比如naive spin lock会在分布式高并发环境下有很大的性能问题
xv6的锁通过xchg这个atomic operation实现

ticket spin lock
ticket spin lock能够保证每个请求者能够按照请求的顺序来一次获得锁，但是不是scalable的

#### cache coherence
缘由：每个CPU有自己的cache,要保证一致性

directory-based 当directory记录的信息被修改了以后，会发送一条probing message来提醒CPU

在多CPU系统上，由于cache consistency必须保证，多个CPU之间需要浪费大量的时间来传输和更新信息

一种简单的fix:在拿锁失败以后暂停一段时间

MCS Lock
MCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。
维护一个链表，一开始的节点的前一个结点是NULL,waiting:0,所以不需要等待
当再次出现一个锁的请求者时，会在链表后添加一个新的节点，将waiting的值设为1,这时会阻塞住，等待waiting变为0
```
mcs_node{
  mcs_node next;
  int is_locked;
}
mcs_lock{
  mcs_node queue;
}
function lock(mcs_lock lock, mcs_node my_node){
  my_node.next = NULL;
  mcs_node predecessor = 
        fetch_and_store(lock.queue, my_node);
  if(predecessor != NULL){
    my_node.is_locked = true;
    predecessor.next = my_node;
    while(my_node.is_locked){};
  }
}
function unlock(mcs_lock lock, mcs_node my_node){
  if(my_node.next == NULL){
    if(compare_and_swap(lock.queue, my_node, NULL){
      return;
    }else{
      while(my_node.next == NULL){};
    }
  }
  my_node.next.is_locked = false;
}
```

### 同步原语

#### 读写锁
基本Assumption
* Shared data that will be read and written by multiple threads
* Allow multiple readers to access shared data when no threads are writing data
* A thread can write shared data only when no other thread is reading or writing the shared data

```
readerFinish() {
  lock(lockRW);
  numReaders--.
  if(numReaders == 0){
    signal(lockRW, condWR);
  };
  unlock(lockRW);
}
```
只需要在numberReaders为0的情况下发送signal,不需要一直broadcast

RCU
RCU是一种同步机制，不需要锁
RCU(Read-Copy Update)，顾名思义就是读-拷贝修改，它是基于其原理命名的。对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。

Lock-Free结构
Copy
Write down any state we need in order to retry
Do the work
Perform the computation
Atomically “test and commit” or retry
Compare saved assumptions with the actual state of the world
If different, undo work, and start over with new state
If preconditions still hold, commit the results and continue
This is where the work becomes visible to the world (ideally)

### BUgs
* Non dead-lock bugs
  * atomicity violations
  * order violations
* Deadlocks
系统安全： Never dereference a user-level pointer
一些原则
Do not call blocking functions with interrupts disabled or spin lock held
Check for NULL results
Do not allocate large stack variables
Do not re-use already-allocated memory
Check user pointers before using them in kernel mode
Release acquired locks 

### Data Race
定义:An undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, but the operations must be done in the proper sequence in order to be done correctly

Happens-Before Relation
For the events A and B,
HB1: On the same sequential thread,  
A  ->  B if A executes before B.

HB2: On the different threads,  
A  ->  B if there is a synchronization that dictates A precedes B.

HB3: If A  ->  B and B  ->  C  then A  ->  C

通过HB定义data race
The definition of data race:
1.a pair of accesses to the same memory location
2.at least one access is a write
3.neither one happens-before the other

通过lock来定义data race
The definition of data race:
1.a pair of accesses to the same memory location
2.at least one access is a write
3.No lock protects all accesses to the same data

死锁
A set of processes is deadlocked when 
every process in the set is waiting for an event that can only be generated by some process in the set

A set of processes are deadlocked iff the following conditions hold simultaneously
Mutual exclusion is required for resource usage
A process is in a “hold-and-wait” state
Preemption of resource usage is not allowed
Circular waiting exists (a cycle exists in the RAG)


